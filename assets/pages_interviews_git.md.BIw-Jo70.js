import{_ as t,c as o,o as i,ag as a}from"./chunks/framework.By2cXeI6.js";const r="/ybhdsg-zhs/assets/image-20210222132936016.DQpSR9Pg.png",l="/ybhdsg-zhs/assets/image-20210222133524146.Cnq2LD6c.png",f=JSON.parse('{"title":"GIT 相关","description":"","frontmatter":{},"headers":[],"relativePath":"pages/interviews/git.md","filePath":"pages/interviews/git.md"}'),p={name:"pages/interviews/git.md"};function c(d,e,s,g,m,n){return i(),o("div",null,[...e[0]||(e[0]=[a('<h1 id="git-相关" tabindex="-1">GIT 相关 <a class="header-anchor" href="#git-相关" aria-label="Permalink to &quot;GIT 相关&quot;">​</a></h1><h2 id="_1-你们的-git-工作流是什么样的" tabindex="-1">1. 你们的 Git 工作流是什么样的？ <a class="header-anchor" href="#_1-你们的-git-工作流是什么样的" aria-label="Permalink to &quot;1. 你们的 Git 工作流是什么样的？&quot;">​</a></h2><p>每个公司采用的 Git 工作流都可能会有差别，有的比较规范，有的比较随意。在这里介绍一个名为 GitFlow 的 git 标准操作流程。</p><p>在 GitFlow 标准下，我们的 git 仓库需要包含以下几个关键分支：</p><ul><li>master：主分支</li><li>develop：主开发分⽀。包含确定即将发布的代码</li><li>feature：新功能分⽀。⼀个新功能对应⼀个分⽀</li><li>release：发布分⽀。发布时⽤的分⽀，⼀般测试阶段发现的 bug 在这个分⽀进⾏修复</li><li>hotfix：热补丁分支。用于修改在线上版本中发现的严重紧急 bug</li></ul><p><strong>GitFlow 的主要优点</strong></p><ol><li>支持并⾏开发</li></ol><p>因为每个新功能都会建⽴⼀个新的 feature 分⽀，从⽽和其他已经完成的功能隔离开，且当只有在新功能完成开发的情况下，其对应的 feature 分⽀才会被合并到主开发分⽀（develop 分支）。</p><p>另外，如果你正在开发某个功能的同时⼜有⼀个新功能需要开始开发，那么你只需把当前 feature 的代码提交后，新建另外⼀个 feature 分⽀即可开发新功能了。</p><p>你也可以随时切回之前的其他 feature 分⽀继续完成该功能的开发。</p><ul><li>协作开发</li></ul><p>因为每个 feature 分⽀上改动的代码都只对该 feature 对应的功能生效，所以不同 feature 分支上的代码在开发时不会互相影响，大家可以相安无事的开发自己负责的功能。</p><p>同时我们可以根据分支的名称，很容易知道每个⼈都在做什么功能。</p><ul><li>发布阶段</li></ul><p>当⼀个新 feature 开发完成时，它会被合并到 develop 分⽀，这就意味着 develop 分支上包含了所有已经开发完成的功能。</p><p>因此，在开发新的 feature 时，我们只需从 develop 分⽀来创建新的分⽀，即可在新的 feature 分支中包含所有已完成的最新功能。</p><ul><li>⽀持紧急修复</li></ul><p>hotfix 分⽀是从某个已经发布的 Tag 上创建出来来，用于紧急修复 Bug。</p><p>该紧急修复只影响这个已经发布的 Tag，⽽不会影响你正在开发的其他新 feature 。</p><p><strong>注意点</strong></p><ol><li><p>feature 分⽀都是从 develop 分⽀上创建的，开发完成后再合并到 develop 分⽀上，等待发布</p></li><li><p>当需要发布时，我们要从 develop 分⽀上创建⼀个 release 分⽀，然后该 release 分⽀会发布到测试环境进⾏测试。如果发现问题的话，就会直接在该分⽀上进⾏修复。所有问题修复之前，会不停重复 <code>发布</code> &gt; <code>测试</code> &gt; <code>修复</code> &gt; <code>重新发布</code> &gt; <code>重新测试</code> 流程。 发布结束，该 release 分⽀会被合并到 develop 以及 master 分⽀，从⽽保证不会有代码丢失</p></li><li><p>master 分⽀只跟踪已经发布的代码，合并到 master 上的 commit 只能来⾃ release 分⽀和 hotfix 分⽀</p></li><li><p>hotfix 分⽀的作⽤是紧急修复⼀些 Bug，它们都是从 master 分⽀上的某个 Tag 建⽴，修复结束后再会被合并到 develop 和 master 分⽀上</p></li></ol><p><a href="https://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="noreferrer">参考文章：Git 工作流</a></p><h2 id="_2-git-的-rebase-和-merge-的区别是什么" tabindex="-1">2. Git 的 rebase 和 merge 的区别是什么？ <a class="header-anchor" href="#_2-git-的-rebase-和-merge-的区别是什么" aria-label="Permalink to &quot;2. Git 的 rebase 和 merge 的区别是什么？&quot;">​</a></h2><p><code>git rebase</code> 和 <code>git merge</code> 两个命令都⽤于从⼀个分⽀获取内容并合并到当前分⽀。</p><p>以一个 <code>feature/todo</code> 分⽀合并到 <code>master</code>主分⽀为例，我们来看一下分别⽤ <code>rebase</code> 和 <code>merge</code> 会有什么不同。</p><p><strong>使用 Merge</strong></p><img src="'+r+'" alt="image-20210222132936016" style="zoom:30%;"><p><code>merge</code> 会⾃动创建⼀个新的 <code>commit</code>， 如果合并时遇到冲突的话，只需要修改后重新 <code>commit</code>。</p><ul><li><p>优点：能记录真实的 <code>commit</code> 情况，包括每个分⽀的详情</p></li><li><p>缺点：由于每次 <code>merge</code> 会⾃动产⽣⼀个 <code>merge commit</code>，因此在使⽤⼀些可视化的 git 工具时会看到这些自动产生的 <code>commit</code>，这些 <code>commit</code> 对于程序员来说没有什么特别的意义，反而会影响阅读</p></li></ul><p><strong>使用 Rebase</strong></p><img src="'+l+'" alt="image-20210222133524146" style="zoom:30%;"><p><code>rebase</code> 会合并之前的 <code>commit</code> 历史。</p><ul><li><p>优点：可以得到更简洁的提交历史，去掉了 <code>merge commit</code></p></li><li><p>缺点：因为合并而产生的代码问题，就不容易定位，因为会重写提交历史信息</p></li></ul><p><strong>建议</strong></p><ul><li><p>当需要保留详细的合并信息时，建议使⽤ <code>git merge</code>，特别是需要将分⽀合并进 <code>master</code> 分⽀时</p></li><li><p>当发现⾃⼰修改某个功能时提交比较频繁，并觉得过多的提交信息对自己来说没有必要，那么可尝试使用 <code>git rebase</code></p></li></ul>',35)])])}const _=t(p,[["render",c]]);export{f as __pageData,_ as default};
