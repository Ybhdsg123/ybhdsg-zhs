import{_ as s,c as i,o as e,ag as n}from"./chunks/framework.By2cXeI6.js";const k=JSON.parse('{"title":"网络分层模型和应用协议","description":"","frontmatter":{},"headers":[],"relativePath":"pages/interviews/networkrotocols.md","filePath":"pages/interviews/networkrotocols.md"}'),t={name:"pages/interviews/networkrotocols.md"};function p(l,a,o,h,d,r){return e(),i("div",null,[...a[0]||(a[0]=[n(`<h1 id="网络分层模型和应用协议" tabindex="-1">网络分层模型和应用协议 <a class="header-anchor" href="#网络分层模型和应用协议" aria-label="Permalink to &quot;网络分层模型和应用协议&quot;">​</a></h1><h2 id="分层模型" tabindex="-1">分层模型 <a class="header-anchor" href="#分层模型" aria-label="Permalink to &quot;分层模型&quot;">​</a></h2><h3 id="分层的意义" tabindex="-1">分层的意义 <a class="header-anchor" href="#分层的意义" aria-label="Permalink to &quot;分层的意义&quot;">​</a></h3><p>当遇到一个复杂问题的时候，可以使用分层的思想把问题简单化 从常理出发，我们可以得出以下结论：</p><ul><li>每层相对独立，只需解决自己的问题</li><li>每层无须考虑上层的交付，仅需把自己的结果交给下层即可</li><li>每层有多种方案可供选择，选择不同的方案不会对上下层造成影响</li><li>每一层会在上一层的基础上增加一些额外信息</li></ul><h3 id="五层网络模型" tabindex="-1">五层网络模型 <a class="header-anchor" href="#五层网络模型" aria-label="Permalink to &quot;五层网络模型&quot;">​</a></h3><p>网络要解决的问题是：<strong>两个程序之间如何交换数据</strong>。</p><p>这是一个非常复杂的问题，因为两个程序有可能出现在不同的设备上。</p><p>面对复杂的问题，可以使用分层的方式来简化。</p><p>经过不断的演化，网络最终形成了五层模型：</p><p><img src="http://mdrs.yuanjin.tech/img/20211008163417.png" alt="image-20211008163417521"></p><h3 id="数据的传输" tabindex="-1">数据的传输 <a class="header-anchor" href="#数据的传输" aria-label="Permalink to &quot;数据的传输&quot;">​</a></h3><p><img src="http://mdrs.yuanjin.tech/img/20211008163458.png" alt="image-20211008163458168"></p><h3 id="四层、五层、七层" tabindex="-1">四层、五层、七层 <a class="header-anchor" href="#四层、五层、七层" aria-label="Permalink to &quot;四层、五层、七层&quot;">​</a></h3><p><img src="http://mdrs.yuanjin.tech/img/20211008164017.png" alt="image-20211008164017299"></p><h2 id="应用层协议" tabindex="-1">应用层协议 <a class="header-anchor" href="#应用层协议" aria-label="Permalink to &quot;应用层协议&quot;">​</a></h2><h3 id="url" tabindex="-1">URL <a class="header-anchor" href="#url" aria-label="Permalink to &quot;URL&quot;">​</a></h3><p>URL（uniform resource locator，统一资源定位符）用于定位网络服务</p><p><img src="http://mdrs.yuanjin.tech/img/202301121041726.png" alt="image-20230112104100679"></p><p>URL 是一个固定格式的字符串</p><p><img src="http://mdrs.yuanjin.tech/img/202301121029498.png" alt="image-20230112102913056"></p><p>它表达了：</p><p>从网络中==哪台计算机（domain）==中的==哪个程序（port）==寻找==哪个服务（path）==，并注明了获取服务的==具体细节（query）==，以及要用什么样的==协议通信（schema）==</p><p>这里面包含了一些细节：</p><ul><li>当协议是<code>http</code>端口为<code>80</code>时，端口可以省略</li><li>当协议是<code>https</code>端口为<code>443</code>时，端口可以省略</li><li><code>schema</code>、<code>domain</code>、<code>path</code>是必填的，其他的根据具体的要求填写</li></ul><h3 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h3><p>超文本传输协议（Hyper Text Transfer Protocol，<em>HTTP</em>）是一个广泛运用于互联网的应用层协议。</p><p>99%的情况下，前端开发者接触的都是 HTTP 协议。</p><p>该协议规定了两个方面的内容：</p><ul><li><strong>传递消息的模式</strong></li><li><strong>传递消息的格式</strong></li></ul><h4 id="传递消息的模式" tabindex="-1">传递消息的模式 <a class="header-anchor" href="#传递消息的模式" aria-label="Permalink to &quot;传递消息的模式&quot;">​</a></h4><p><img src="http://mdrs.yuanjin.tech/img/202301121100790.png" alt="image-20230112110047746"></p><p>HTTP 使用了一种极为简单的消息传递模式，「请求-响应」模式</p><p>发起请求的称之为客户端，接收请求并完成响应的称之为服务器。</p><p>「请求-响应」完成后，一次交互结束。</p><h4 id="传递消息的格式" tabindex="-1">传递消息的格式 <a class="header-anchor" href="#传递消息的格式" aria-label="Permalink to &quot;传递消息的格式&quot;">​</a></h4><p><img src="http://mdrs.yuanjin.tech/img/202301132143345.png" alt="image-20230113214343300"></p><p>HTTP 的消息格式是一种纯文本的格式，文本分为三个部分：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>请求行</span></span>
<span class="line"><span>请求头</span></span>
<span class="line"><span></span></span>
<span class="line"><span>请求体</span></span></code></pre></div><p><strong>具体每一部分写什么内容，要看具体的服务要求</strong></p><h4 id="试一试" tabindex="-1">试一试 <a class="header-anchor" href="#试一试" aria-label="Permalink to &quot;试一试&quot;">​</a></h4><p>有非常多的工具可以发送 http 请求，这里推荐一个非常直观的工具</p><ol><li><p>安装<code>vscode</code>插件<code>REST Clinet</code></p><p><img src="http://mdrs.yuanjin.tech/img/202301121145973.png" alt="image-20230112114542925"></p></li><li><p>新建文件<code>xxx.http</code></p></li><li><p>编写请求文本</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">POST</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">api</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">login </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HTTP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Host</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: study.duyiedu.com</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Content</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: application</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">json</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;loginId&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;admin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;loginPwd&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;123123&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>发送请求</p></li></ol><h4 id="熟悉关键信息" tabindex="-1">熟悉关键信息 <a class="header-anchor" href="#熟悉关键信息" aria-label="Permalink to &quot;熟悉关键信息&quot;">​</a></h4><h5 id="请求方法" tabindex="-1">请求方法 <a class="header-anchor" href="#请求方法" aria-label="Permalink to &quot;请求方法&quot;">​</a></h5><p>请求行中的第一个单词是请求方法</p><p><strong>在 HTTP 协议中，请求方法仅有语义的区别</strong>，只是表达了这次请求的「愿望」。</p><blockquote><p>关于请求方法的协议原文见 <a href="https://www.rfc-editor.org/rfc/rfc7231.html" target="_blank" rel="noreferrer">HTTP/1.1 规范 RFC7231-Chapter4</a></p><p><img src="http://mdrs.yuanjin.tech/img/202301131908971.png" alt="image-20230113190854930"></p></blockquote><p>比如<code>GET</code>表达了客户端想要获取一些东西，<code>POST</code>表达了客户端想要提交一些东西</p><p>常见的请求方法有：</p><ul><li><code>GET</code>：获取</li><li><code>POST</code>：提交</li><li><code>PUT</code>：修改</li><li><code>DELETE</code>：删除</li></ul><p><strong>具体在开发中应该选择什么请求方法，一定是看服务方的要求</strong></p><p>通常情况下：</p><ul><li>获取数据一般使用<code>GET</code></li><li>提交数据一般使用<code>POST</code></li><li>各种静态资源的获取，一般使用<code>GET</code></li></ul><h5 id="请求头-host" tabindex="-1">请求头 - <code>Host</code> <a class="header-anchor" href="#请求头-host" aria-label="Permalink to &quot;请求头 - \`Host\`&quot;">​</a></h5><p><code>Host</code>标注了<code>URL</code>地址中的<code>Domain + Port</code></p><p>示例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Host: study.duyiedu.com</span></span></code></pre></div><h5 id="请求头-content-type" tabindex="-1">请求头 - <code>Content-Type</code> <a class="header-anchor" href="#请求头-content-type" aria-label="Permalink to &quot;请求头 - \`Content-Type\`&quot;">​</a></h5><p><code>Content-Type</code>标注了附带的请求体是什么格式</p><p>比如，请求体的数据为<code>loginId:admin, loginPwd:123456</code>，请求体可以用不同的格式发出</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Content</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: application</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">www</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">form</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">urlencoded</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loginId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">admin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loginPwd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123123</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Content-Type: application/json</span></span>
<span class="line"><span></span></span>
<span class="line"><span>{ &quot;loginId&quot;: &quot;admin&quot;, &quot;loginPwd&quot;: &quot;123123&quot; }</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryraPtlntBIqy4X2Ho</span></span>
<span class="line"><span></span></span>
<span class="line"><span>------WebKitFormBoundaryraPtlntBIqy4X2Ho</span></span>
<span class="line"><span>Content-Disposition: form-data; name=&quot;loginId&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>admin</span></span>
<span class="line"><span>------WebKitFormBoundaryraPtlntBIqy4X2Ho</span></span>
<span class="line"><span>Content-Disposition: form-data; name=&quot;loginPwd&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>123456</span></span>
<span class="line"><span>------WebKitFormBoundaryraPtlntBIqy4X2Ho--</span></span></code></pre></div><h5 id="响应码" tabindex="-1">响应码 <a class="header-anchor" href="#响应码" aria-label="Permalink to &quot;响应码&quot;">​</a></h5><p>响应码（状态码、消息码）是响应行中的一个数字，后面往往跟上一个对应的单词，用于表达服务器对这个响应的整体「态度」</p><p>常见的响应码有：</p><p><img src="http://mdrs.yuanjin.tech/img/202301121310570.png" alt="image-20230112131000507"></p><p>常见的状态码有：</p><ol><li><p>200 OK：一切正常。</p></li><li><p>301 Moved Permanently：资源已被永久重定向。</p><p><code>你的请求我收到了，但是呢，你要的东西不在这个地址了，我已经永远的把它移动到了一个新的地址，麻烦你取请求新的地址，地址我放到了响应头的Location中了</code></p><blockquote><p>试试请求：www.douyutv.com</p></blockquote></li><li><p>302 Found：资源已被临时重定向。</p><p><code>你的请求我收到了，但是呢，你要的东西不在这个地址了，我临时的把它移动到了一个新的地址，麻烦你取请求新的地址，地址我放到了请求头的Location中了</code></p></li><li><p>304 Not Modified：文档内容未被修改。</p><p><code>你的请求我收到了，你要的东西跟之前是一样的，没有任何的变化，所以我就不给你结果了，你自己就用以前的吧。啥？你没有缓存以前的内容，关我啥事</code></p></li><li><p>400 Bad Request：语义有误，当前请求无法被服务器理解。</p><p><code>你给我发的是个啥啊，我听都听不懂</code></p></li><li><p>403 Forbidden：服务器拒绝执行。</p><p><code>你的请求我已收到，但是我就是不给你东西</code></p></li><li><p>404 Not Found：资源不存在。</p><p><code>你的请求我收到了，但我没有你要的东西</code></p></li><li><p>500 Internal Server Error：服务器内部错误。</p><p><code>你的请求我已收到，但这道题我不会，解不出来，先睡了</code></p></li></ol><h5 id="响应头-content-type" tabindex="-1">响应头 - <code>Content-Type</code> <a class="header-anchor" href="#响应头-content-type" aria-label="Permalink to &quot;响应头 - \`Content-Type\`&quot;">​</a></h5><p><code>Content-Type</code>标注了附带的响应体是什么格式</p><p>常见的值有：</p><ol><li><code>text/plain</code>: 普通的纯文本</li><li><code>text/html</code>：html 文档</li><li><code>text/javascript</code> 或 <code>application/javascript</code>：js 代码</li><li><code>text/css</code>：css 代码</li><li><code>image/jpeg</code>：jpg 图片</li><li><code>attachment</code>：附件</li><li>其他<code>MIME</code>类型</li></ol>`,74)])])}const g=s(t,[["render",p]]);export{k as __pageData,g as default};
