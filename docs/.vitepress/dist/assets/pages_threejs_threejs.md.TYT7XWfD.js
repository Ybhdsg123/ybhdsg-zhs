import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.By2cXeI6.js";const c=JSON.parse('{"title":"创建 3D 场景时，唯一的限制是您的想象力 - 以及您的技术知识深度。","description":"","frontmatter":{},"headers":[],"relativePath":"pages/threejs/threejs.md","filePath":"pages/threejs/threejs.md"}'),l={name:"pages/threejs/threejs.md"};function e(h,s,p,k,r,o){return n(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="创建-3d-场景时-唯一的限制是您的想象力-以及您的技术知识深度。" tabindex="-1">创建 3D 场景时，唯一的限制是您的想象力 - 以及您的技术知识深度。 <a class="header-anchor" href="#创建-3d-场景时-唯一的限制是您的想象力-以及您的技术知识深度。" aria-label="Permalink to &quot;创建 3D 场景时，唯一的限制是您的想象力 - 以及您的技术知识深度。&quot;">​</a></h1><h2 id="_1-所有步骤" tabindex="-1">1. 所有步骤 <a class="header-anchor" href="#_1-所有步骤" aria-label="Permalink to &quot;1. 所有步骤&quot;">​</a></h2><details class="details custom-block"><summary>Details</summary><ol><li>初始设置</li><li>创建场景</li><li>创建相机</li><li>创建立方体并将其添加到场景中</li><li>创建渲染器</li></ol><p>附加任务：设置场景的大小</p><ol start="6"><li>渲染场景</li></ol></details><h2 id="_2-分模块-每个模块都是一个文件" tabindex="-1">2. 分模块（每个模块都是一个文件） <a class="header-anchor" href="#_2-分模块-每个模块都是一个文件" aria-label="Permalink to &quot;2. 分模块（每个模块都是一个文件）&quot;">​</a></h2><h3 id="_2-1-模块分为两类-组件-components-和-系统级-system" tabindex="-1">2.1 模块分为两类 组件（components）和 系统级（system) <a class="header-anchor" href="#_2-1-模块分为两类-组件-components-和-系统级-system" aria-label="Permalink to &quot;2.1 模块分为两类 组件（components）和 系统级（system)&quot;">​</a></h3><h3 id="_2-2-组件-components-是可以放置到场景中的任何东西-例如立方体、相机和场景本身" tabindex="-1">2.2 组件（components）是可以放置到场景中的任何东西，例如立方体、相机和场景本身， <a class="header-anchor" href="#_2-2-组件-components-是可以放置到场景中的任何东西-例如立方体、相机和场景本身" aria-label="Permalink to &quot;2.2 组件（components）是可以放置到场景中的任何东西，例如立方体、相机和场景本身，&quot;">​</a></h3><h3 id="_2-3-而系统是在组件或其他系统上运行的东西。在这里-是渲染器和大小调整函数-resizer" tabindex="-1">2.3 而系统是在组件或其他系统上运行的东西。在这里，是渲染器和大小调整函数(Resizer) <a class="header-anchor" href="#_2-3-而系统是在组件或其他系统上运行的东西。在这里-是渲染器和大小调整函数-resizer" aria-label="Permalink to &quot;2.3 而系统是在组件或其他系统上运行的东西。在这里，是渲染器和大小调整函数(Resizer)&quot;">​</a></h3><h2 id="_3-场景图" tabindex="-1">3. 场景图 <a class="header-anchor" href="#_3-场景图" aria-label="Permalink to &quot;3. 场景图&quot;">​</a></h2><ol><li>场景图中的每个对象（顶级场景除外）只有一个父对象，并且可以有任意数量的子对象。</li><li>通过<code>.children</code>数组来访问所有子对象，也可以通过<code>getObjectByName</code>（有名称的话）</li><li>因为一个对象只能有一个父对象，所以在将 A 下面的字元素 a 移动到 B 对象，那么 A 对象会删除</li><li>我们最终在屏幕上看到的是世界空间。</li></ol><h2 id="_4-世界空间和局部空间" tabindex="-1">4. 世界空间和局部空间 <a class="header-anchor" href="#_4-世界空间和局部空间" aria-label="Permalink to &quot;4. 世界空间和局部空间&quot;">​</a></h2><p>顶级场景定义了世界空间，而其他每个对象都定义了自己的局部空间。</p><h2 id="_5-平移-translation-缩放-scale-旋转-rotation" tabindex="-1">5. 平移(translation) 缩放(scale) 旋转(rotation) <a class="header-anchor" href="#_5-平移-translation-缩放-scale-旋转-rotation" aria-label="Permalink to &quot;5. 平移(translation) 缩放(scale) 旋转(rotation)&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li>平移 和 缩放 都存储于 <code>Vector3</code> 中</li><li>相机和灯光（除了<code> RectAreaLight</code>）没有大小，因此缩放它们没有意义。更改 camera.scale 或 light.scale 将没有效果。</li></ol></div><details class="details custom-block"><summary>平移(translation)</summary><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// translate one axis at a time</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mesh.position.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mesh.position.y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mesh.position.z </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// translate all three axes at once</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mesh.position.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></details><details class="details custom-block"><summary>缩放(scale)</summary><p><strong>1. 小于 0 的比例会镜像对象</strong><strong>2. 缩放没有单位</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// when we create a mesh...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mesh</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Mesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ... internally, three.js creates a Vector3 for us:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mesh.scale </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vector3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></details><details class="details custom-block"><summary>旋转(scale)</summary><p>请记下这两种旋转对象的方法： <strong>1. 使用欧拉角，使用 Euler 类表示并存储在.rotation 属性中。</strong><strong>2. 使用四元数，使用 Quaternion 类表示并存储在.quaternion 属性中。</strong><strong>3. 灯光无法旋转，灯光从某个位置照射到目标，灯光的角度是根据目标的位置而不是.rotation 属性计算得出的。</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Euler } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;three&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//  使用欧拉角</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> euler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Euler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用四元数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mesh.quaternion </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Quaternion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div></details><h2 id="_6-three-js-中的所有其他角度都是使用-弧度而不是-度数-指定的-只有透视投影的视野-fov-是度数" tabindex="-1">6 three.js 中的所有其他角度都是使用 弧度而不是 度数 指定的，只有透视投影的视野(fov)是度数 <a class="header-anchor" href="#_6-three-js-中的所有其他角度都是使用-弧度而不是-度数-指定的-只有透视投影的视野-fov-是度数" aria-label="Permalink to &quot;6 three.js 中的所有其他角度都是使用 弧度而不是 度数 指定的，只有透视投影的视野(fov)是度数&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">degToRad 将度数变为弧度</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { MathUtils } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;three&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rads</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MathUtils.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">degToRad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">90</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></div><h2 id="_7-变换矩阵" tabindex="-1">7. 变换矩阵 <a class="header-anchor" href="#_7-变换矩阵" aria-label="Permalink to &quot;7. 变换矩阵&quot;">​</a></h2><p>向量和欧拉角对我们人类来说（相对）容易使用，但它们对于计算机处理的效率并不高。而矩阵效率更高</p><p>4X4 矩阵用 <code>Matrix4</code> 3X3 矩阵用 <code>Matrix3</code></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个网格</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mesh</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Mesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//three.js 会自动创建 局部矩阵 和 世界矩阵</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mesh.matrix </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Matrix4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mesh.matrixWorld </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Matrix4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><details class="details custom-block"><summary>局部矩阵</summary><ol><li>每个对象都不止一个，而是有两个变换矩阵。其中第一个是局部矩阵，它包含一个对象的<code>.position</code>、<code>.rotation</code>和<code>.scale</code>组合。局部矩阵存储在 <code>Object3D.matrix</code>属性中。继承自<code>Object3D</code>的每个对象都具有此属性。</li><li><code>.position</code>存储在矩阵的前三行的第四列</li><li><code>.rotation</code>存储在矩阵的前三行的对角线上</li></ol></details><details class="details custom-block"><summary>世界矩阵</summary><ol><li>世界矩阵存储在 <code>Object3D.matrixWorld</code>属性中</li><li>**世界矩阵存储对象在世界空间中的位置。**如果对象是场景的直接子对象，那么世界矩阵和局部矩阵是相同的，否则则很大可能不同</li></ol></details><h2 id="_8-动画循环" tabindex="-1">8. 动画循环 <a class="header-anchor" href="#_8-动画循环" aria-label="Permalink to &quot;8. 动画循环&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li><strong>我们的动画循环不会以固定速率生成帧,该循环将尝试以硬件定义的屏幕刷新率渲染帧</strong>,会在旧的慢速设备上旋转得更慢，而在花哨的新 240Hz 游戏显示器上它将进入超高速状态。240=4×60，这意味着立方体将以所需速度的四倍旋转！</li><li><strong>我们需要将动画速度与帧速率解耦</strong>。我们将这样做：当我们告诉一个对象.tick 前进一帧时，我们将根据前一帧花费的时间来缩放移动的大小。这样，随着帧速率的变化，我们将不断调整每个.tick 的大小，以使动画保持流畅。</li><li><code>.getDelta</code> <strong>告诉我们自上次调用</strong><code>.getDelta</code>以来已经过去了多少时间。如果我们在每一帧开始时调用它一次，并且只调用一次，它将告诉我们前一帧花了多长时间。**注意：如果您每帧调用<code>.getDelta</code>不止一次，后续调用的测量值将接近于零。**只在一帧开始时调用<code>.getDelta</code>一次</li></ol><p>:::detail Clock</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Clock } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;three&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> clock</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Clock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> delta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getDelta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div></div><p>:::</p><details class="details custom-block"><summary>.setAnimationLoop</summary><ol><li>内部，循环是使用 .requestAnimationFrame</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { WebGLRenderer } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;three&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> renderer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WebGLRenderer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 开启这个动画 ，这将一遍又一遍地调用renderer.render以生成帧流。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">renderer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setAnimationLoop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  renderer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scene, camera);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 通过传递null作为回调来取消正在运行的循环：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">renderer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setAnimationLoop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></details><h2 id="_9-纹理" tabindex="-1">9. 纹理 <a class="header-anchor" href="#_9-纹理" aria-label="Permalink to &quot;9. 纹理&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><h3 id="图像和纹理的区别" tabindex="-1">图像和纹理的区别 <a class="header-anchor" href="#图像和纹理的区别" aria-label="Permalink to &quot;图像和纹理的区别&quot;">​</a></h3><ol><li>图像是设计用于人类观看的 2D 图片。</li><li>纹理是专门为 3D 图形中的各种目的而准备的数据。</li></ol><h3 id="像素和纹素" tabindex="-1">像素和纹素 <a class="header-anchor" href="#像素和纹素" aria-label="Permalink to &quot;像素和纹素&quot;">​</a></h3><ol><li>构成屏幕的像素是实际的物理对象，LED 或 OLED 或其他一些高科技设备，而构成图像的像素只是存储在文件中的数字。</li><li>我们将称<strong>构成屏幕像素的点为像素 pixels</strong>，但将<strong>构成纹理的点称为纹素 texels</strong>。</li></ol><h3 id="uv-映射" tabindex="-1">UV 映射 <a class="header-anchor" href="#uv-映射" aria-label="Permalink to &quot;UV 映射&quot;">​</a></h3><ol><li>UV 映射是一种获取二维纹理并将其映射到三维几何体的方法。想</li><li></li></ol></div><ol><li><strong>纹理可用于存储各种数据</strong>，例如颜色、凹凸度、不透明度、表面上的小阴影（称为环境光遮蔽）、光照、金属度和粗糙度等等。例如，不同的材料接受不同种类和组合的纹理，因此 MeshBasicMaterial 不接受所有与 MeshStandardMaterial 相同的纹理。</li><li>一个以 PNG 格式存储的普通 2D 图像文件，我们将使用<code>TextureLoader</code>加载它，这将返回 <code>Texture</code>类的一个实例。您可以以相同的方式使用浏览器支持的任何图像格式，例如 PNG、JPG、GIF、BMP。</li><li>还有一些专用图像格式的加载器，如<code>HDR</code>、<code>EXR</code>和<code>TGA</code>，它们具有相应的加载器，如 <code>TGALoader</code>。同样，一旦加载，我们将获得一个<code>Texture</code>实例，我们可以以与加载的 PNG 或 JPG 图像大致相同的方式使用它。</li><li>three.js 还支持许多其他类型的非简单 2D 图像的纹理，例如 视频纹理、 3D 纹理、 画布纹理、 压缩纹理、 立方体纹理、 矩形纹理等等。</li><li><strong>纹理贴图</strong>：尽管在技术上不正确，但纹理通常也称为<strong>贴图</strong>，甚至是<strong>纹理贴图</strong>，尽管<strong>贴图</strong>最常用于将纹理分配给材质。当使用纹理来表示颜色时，我们会说<strong>我们正在将纹理分配给材质上的颜色贴图槽</strong>。下面，我们将向您展示如何将 uv-test-bw.png 纹理分配给 MeshStandardMaterial 的颜色贴图槽。</li></ol><details class="details custom-block"><summary>Texture 类</summary><ol><li><strong>类 Texture 是 HTML 图像元素的包装器</strong>，具有一些与用作纹理而不是普通图像相关的额外设置。</li><li>可以在<code>image.texture</code>下访问原始图像</li><li><code>TextureLoader.load</code>方法可以加载任何标准图像格式的纹理，例如 PNG、JPEG、GIF、BMP 等。</li><li>我们使用 <code>.color</code>属性设置材质的颜色。在这里，我们将<code>texture</code>分配给 <code>material.map</code>属性，该属性描述颜色在对象表面上的变化方式</li><li><strong><em>通常，我们要么设置一个<code>.color</code>，或者要么设置一个<code>.map</code></em></strong>，<strong>但不能同时设置。如果我们确实同时设置了，纹理中的颜色则将乘以.color 属性</strong>。</li><li>常见用例：<strong>将颜色设置为灰色阴影以使纹理变暗</strong>。由于白色是默认颜色，<strong>设置<code>.color</code>为白色不会影响纹理</strong>。因此，无法使用.color 来使纹理变亮，<strong>您只能将其变暗。</strong></li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在构造函数中将纹理分配给材质</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> material</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MeshStandardMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  map: texture,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建材质后分配纹理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> material</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MeshStandardMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">material.map </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> texture;</span></span></code></pre></div></details><h2 id="_10-orbitcontrols-相机控制插件" tabindex="-1">10. OrbitControls 相机控制插件 <a class="header-anchor" href="#_10-orbitcontrols-相机控制插件" aria-label="Permalink to &quot;10. OrbitControls 相机控制插件&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li><strong><code>OrbitControls</code>构造函数有两个参数：<code>Camera</code>和 <code>HTMLDOMElement</code></strong>,我们将使用相机作为第一个参数，使用存储在<code>renderer.domElement</code>中的画布作为第二个参数。</li><li><strong>控件将监听我们作为第二个参数传入的元素上的用户输入</strong>。页面的其余部分将不受影响。</li><li>默认情况下，控件围绕场景中心旋转，即点(0,0,0)。 这存储在<code>controls.target</code>属性中，即<code>Vector3</code>。</li><li><strong>启用阻尼以增加真实感</strong>，调整 <code>.dampingFactor</code>以控制相机停止的速度，<strong>为了使阻尼起作用，我们必须在动画循环中的每一帧都调用 <code>controls.update</code>。如果我们是 按需渲染帧而不是使用循环，我们就不能使用阻尼。</strong></li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createControls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">camera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">canvas</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 创建控件controls</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> controls</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OrbitControls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera, canvas);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 设置控件的目标</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  controls.target.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 还可以通过复制对象的位置来将控件指向对象。指向对象的位置</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 每当您平移控件（使用鼠标右键）时，目标也会平移。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果需要固定目标，可以使用controls.enablePan = false禁用平移。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  controls.target.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">copy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cube.position);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> controls;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></div><details class="details custom-block"><summary><code> OrbitControls</code>相机控制插件</summary><ol><li><code>OrbitControls</code>相机控制插件,它允许您使用触摸、鼠标或键盘来环绕、平移和缩放相机。通过这些控件，我们可以从各个角度查看场景，放大以检查微小细节，或缩小以鸟瞰概览。</li><li>使用鼠标左键或单指轻扫，围绕固定点旋转。</li><li>使用鼠标右键、箭头键或两指滑动来平移相机。</li><li>使用滚轮或捏合手势缩放相机。</li></ol></details><details class="details custom-block"><summary>在使用 OrbitControls 时让相机工作</summary><ol><li>控件 controls 就位后，我们将相机的控制权交给了他们。但是，有时您需要收回控制权以手动定位相机。有两种方法可以解决这个问题：</li></ol><ul><li>1.1 剪切/跳转到新的摄像机位置</li><li>1.2 平滑动画到新的相机位置</li></ul><h3 id="_1-剪切到新的摄像机位置" tabindex="-1">1. 剪切到新的摄像机位置# <a class="header-anchor" href="#_1-剪切到新的摄像机位置" aria-label="Permalink to &quot;1. 剪切到新的摄像机位置#&quot;">​</a></h3><ol><li>要执行相机剪切，请照常更新相机的变换，然后调用<code>controls.update</code>：</li><li>如果您在循环中调用.update，则无需手动操作，只需移动相机即可</li><li>**注意：**当您移动相机时，<code>controls.target</code>不会移动。如果您没有移动它，它将保持在场景的中心。当您将相机移动到新位置但保持目标不变时，相机不仅会移动，还会旋转，以便继续指向目标。这意味着在使用控件时，相机移动可能无法按预期工作。通常，您需要同时移动相机和目标以获得所需的结果。</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用OrbitControls时手动调整相机变换</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// move the camera</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">camera.position.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// and/or rotate the camera</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">camera.rotation.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// then tell the controls to update</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h3 id="_2-平滑过渡到新的相机位置" tabindex="-1">2. 平滑过渡到新的相机位置 <a class="header-anchor" href="#_2-平滑过渡到新的相机位置" aria-label="Permalink to &quot;2. 平滑过渡到新的相机位置&quot;">​</a></h3><ol><li>如果您想将相机平滑地动画移动到一个新位置，您可能需要同时转换相机和目标，而最好的做这件事的地方就是<code>controls.tick</code>方法中。 <strong>但是：</strong>，您需要在动画期间禁用控件，否则，如果用户在动画完成之前尝试移动相机，您最终会遇到与动画冲突的控件，通常会导致灾难性的后果。</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 为相机或目标设置动画时禁用控件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.enabled </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="_3-保存和恢复视图状态" tabindex="-1">3. 保存和恢复视图状态 <a class="header-anchor" href="#_3-保存和恢复视图状态" aria-label="Permalink to &quot;3. 保存和恢复视图状态&quot;">​</a></h3><ol><li>您可以使用 <code>.saveState</code>保存当前视图，然后使用<code> .reset</code>恢复它：</li><li>如果我们在没有先调用<code>.saveState</code>的情况下调用<code>.reset</code>，相机将跳回到我们创建控件时的位置。</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 保存状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">saveState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 恢复状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h3 id="_4-销毁控件-controls" tabindex="-1">4. 销毁控件 Controls <a class="header-anchor" href="#_4-销毁控件-controls" aria-label="Permalink to &quot;4. 销毁控件 Controls&quot;">​</a></h3><ol><li>可以使用 <code>.dispose</code>清理它们，这将从画布中删除控件创建的所有事件侦听器。</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从画布中删除所有事件侦听</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div></details><details class="details custom-block"><summary>使用 OrbitControls 按需渲染</summary><ol><li>因为循环确实有一些缺点，例如增加移动设备上的电池耗电量。因此，有时我们会选择按需渲染帧，而不是使用循环生成恒定的帧流。</li><li>我们的应用有了轨道控件，<strong>每当用户与你的场景交互时，控件都会将相机移动到一个新的位置，</strong> 当这种情况发生时<strong>你必须绘制一个新的帧</strong>，否则<strong>你将无法看到相机已移动</strong>。如果您使用的是动画循环，那不是问题。但是，如果我们是按需渲染，我们将不得不想出其他办法来解决这个问题</li><li><code>OrbitControls</code>提供了一种在相机移动时生成新帧的简单方法。控件有一个自定义事件<code>change</code>，我们可以使用 <code>addEventListener</code>来监听。<strong>每当用户交互导致控件移动相机时，都会触发此事件。</strong></li></ol><h3 id="使用-orbitcontrols-按需渲染" tabindex="-1">使用 OrbitControls 按需渲染 <a class="header-anchor" href="#使用-orbitcontrols-按需渲染" aria-label="Permalink to &quot;使用 OrbitControls 按需渲染&quot;">​</a></h3><p>要使用轨道控件按需渲染，您必须在此事件触发时渲染一帧：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;change&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  renderer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scene, camera);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></details><details class="details custom-block"><summary>OrbitControls 配置</summary><h3 id="_1-启用或禁用控件" tabindex="-1">1. 启用或禁用控件 <a class="header-anchor" href="#_1-启用或禁用控件" aria-label="Permalink to &quot;1. 启用或禁用控件&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//  启用或禁用控件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.enabled </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 单独设置三种控制模式中的一种</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.enableRotate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.enableZoom </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.enablePan </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="_2-监听按键事件并使用箭头键平移相机" tabindex="-1">2. 监听按键事件并使用箭头键平移相机 <a class="header-anchor" href="#_2-监听按键事件并使用箭头键平移相机" aria-label="Permalink to &quot;2. 监听按键事件并使用箭头键平移相机&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 启用箭头键</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listenToKeyEvents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window);</span></span></code></pre></div><h3 id="_3-自动旋转-autorotate将使相机自动围绕-target旋转-然后-autorotatespeed控制速度" tabindex="-1">3. 自动旋转：<code>.autoRotate</code>将使相机自动围绕<code>.target</code>旋转，然后 <code>.autoRotateSpeed</code>控制速度 <a class="header-anchor" href="#_3-自动旋转-autorotate将使相机自动围绕-target旋转-然后-autorotatespeed控制速度" aria-label="Permalink to &quot;3. 自动旋转：\`.autoRotate\`将使相机自动围绕\`.target\`旋转，然后 \`.autoRotateSpeed\`控制速度&quot;">​</a></h3><p>与<code>.enableDamping</code>一样，您必须在每一帧都调用<code>controls.update</code>才能使其正常工作。 <strong>请注意，如果控件被禁用，.autoRotate 仍然可以工作。</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自动旋转</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.autoRotate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 控制速度</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.autoRotateSpeed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="_4-限制缩放-限制控件放大或缩小的距离-确保mindistance不小于-相机的近剪裁平面且maxdistance不大于-相机的远剪裁平面。此外-mindistance-必须小于-maxdistance。" tabindex="-1">4. 限制缩放：限制控件放大或缩小的距离，<strong>确保<code>minDistance</code>不小于 相机的近剪裁平面且<code>maxDistance</code>不大于 相机的远剪裁平面</strong>。此外，<strong>minDistance 必须小于 maxDistance。</strong> <a class="header-anchor" href="#_4-限制缩放-限制控件放大或缩小的距离-确保mindistance不小于-相机的近剪裁平面且maxdistance不大于-相机的远剪裁平面。此外-mindistance-必须小于-maxdistance。" aria-label="Permalink to &quot;4. 限制缩放：限制控件放大或缩小的距离，**确保\`minDistance\`不小于 相机的近剪裁平面且\`maxDistance\`不大于 相机的远剪裁平面**。此外，**minDistance 必须小于 maxDistance。**&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.minDistance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.maxDistance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="_5-限制旋转-限制控件的水平旋转-方位角-和垂直-极角" tabindex="-1">5. 限制旋转：限制控件的水平旋转（方位角）和垂直（极角） <a class="header-anchor" href="#_5-限制旋转-限制控件的水平旋转-方位角-和垂直-极角" aria-label="Permalink to &quot;5. 限制旋转：限制控件的水平旋转（方位角）和垂直（极角）&quot;">​</a></h3><p><strong>旋转是使用弧度指定的，而不是度数，并且 π 弧度等于 180</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 水平旋转（方位角）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.minAzimuthAngle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Infinity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// default</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.maxAzimuthAngle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Infinity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// default</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 垂直（极角）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.minPolarAngle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// default</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controls.maxPolarAngle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// default</span></span></code></pre></div></details>`,38)])])}const g=i(l,[["render",e]]);export{c as __pageData,g as default};
