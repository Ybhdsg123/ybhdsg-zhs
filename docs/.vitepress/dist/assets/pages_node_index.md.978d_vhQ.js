import{_ as l,C as h,c as e,o as p,ag as n,j as i,G as k,a}from"./chunks/framework.By2cXeI6.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pages/node/index.md","filePath":"pages/node/index.md"}'),d={name:"pages/node/index.md"},r={class:"tip custom-block"};function o(E,s,c,g,y,u){const t=h("MyText");return p(),e("div",null,[s[4]||(s[4]=n(`<h2 id="node-相关" tabindex="-1">node 相关 <a class="header-anchor" href="#node-相关" aria-label="Permalink to &quot;node 相关&quot;">​</a></h2><h2 id="node-js-并不是语言-而是一个-javascript-运行时环境-它的语言是-javascript。" tabindex="-1"><strong>Node.js 并不是语言，而是一个 JavaScript 运行时环境，它的语言是 JavaScript。</strong> <a class="header-anchor" href="#node-js-并不是语言-而是一个-javascript-运行时环境-它的语言是-javascript。" aria-label="Permalink to &quot;**Node.js 并不是语言，而是一个 JavaScript 运行时环境，它的语言是 JavaScript。**&quot;">​</a></h2><p>这就跟 PHP、Python、Ruby 这类不一样，它们既代表语言，也可代表执行它们的运行时环境（或解释器）。</p><h2 id="📖-node-js-入门指南和实践" tabindex="-1">📖 <a href="https://mp.weixin.qq.com/s/x8DrHpNNGvMDOw9IjEHruQ" target="_blank" rel="noreferrer">Node.js 入门指南和实践</a> <a class="header-anchor" href="#📖-node-js-入门指南和实践" aria-label="Permalink to &quot;📖 [Node.js 入门指南和实践](https://mp.weixin.qq.com/s/x8DrHpNNGvMDOw9IjEHruQ)&quot;">​</a></h2><h2 id="🚀-7-天学会-node-js" tabindex="-1">🚀 <a href="http://www.nodejs.com.cn/7-days-nodejs/#2.5.5" target="_blank" rel="noreferrer">7 天学会 node.js</a> <a class="header-anchor" href="#🚀-7-天学会-node-js" aria-label="Permalink to &quot;🚀 [7 天学会 node.js](http://www.nodejs.com.cn/7-days-nodejs/#2.5.5)&quot;">​</a></h2><h2 id="🚀-node-js-入门教程" tabindex="-1">🚀 <a href="https://juejin.cn/book/7304230207953567755/section/7304643411662635044?scrollMenuIndex=1" target="_blank" rel="noreferrer">node.js 入门教程</a> <a class="header-anchor" href="#🚀-node-js-入门教程" aria-label="Permalink to &quot;🚀 [node.js 入门教程](https://juejin.cn/book/7304230207953567755/section/7304643411662635044?scrollMenuIndex=1)&quot;">​</a></h2><h2 id="🔥-nodejs链接" tabindex="-1">🔥 nodejs链接 <a class="header-anchor" href="#🔥-nodejs链接" aria-label="Permalink to &quot;🔥 nodejs链接&quot;">​</a></h2><p><a href="https://juejin.cn/book/7304230207953567755/section/7304642080868204555?scrollMenuIndex=1" target="_blank" rel="noreferrer">1. 全局对象</a><code>JavaScript</code> 中存在一个特殊的全局对象，可以在任意位置被访问，通常用 <code>globalThis</code> 指代。在浏览器中，指向 <code>window</code> 这个全局对象，而 <code>Node.js</code> 中指向 <code>global，</code></p><p><a href="https://juejin.cn/book/7304230207953567755/section/7304643411662635044?scrollMenuIndex=1" target="_blank" rel="noreferrer">2. path路径处理</a></p><p><a href="https://juejin.cn/book/7304230207953567755/section/7304642414130987020?scrollMenuIndex=1" target="_blank" rel="noreferrer">3. fs文件系统</a><code>fs (File system)</code> 是文件系统模块，用于操作文件和目录。支持同步 (sync) 或者异步 (async/callback) 调用，其中同步调用会阻塞主线程，异步调用不会阻塞。</p><p><a href="https://juejin.cn/book/7304230207953567755/section/7304643989746450468?scrollMenuIndex=1" target="_blank" rel="noreferrer">4. util 模块</a>util 模块是一个工具模块，提供了一些常用的辅助函数。</p><h2 id="🔥-node-常用" tabindex="-1">🔥 node 常用 <a class="header-anchor" href="#🔥-node-常用" aria-label="Permalink to &quot;🔥 node 常用&quot;">​</a></h2><h3 id="_1-process全局变量" tabindex="-1">1. <code>process</code>全局变量 <a class="header-anchor" href="#_1-process全局变量" aria-label="Permalink to &quot;1. \`process\`全局变量&quot;">​</a></h3><ul><li><code>process</code>：一个全局变量，提供了有关当前 Node.js 进程的信息并对其进行控制</li><li>由于 JavaScript 是一个单线程语言，所以通过 node xxx 启动一个文件后，只有一条主线程</li></ul><details class="details custom-block"><summary><code>process</code>常见属性</summary><ul><li>process.env：环境变量，例如通过 \`process.env.NODE_ENV 获取不同环境项目配置信息</li><li>process.nextTick：这个在谈及 EventLoop 时经常为会提到</li><li>process.pid：获取当前进程 id</li><li>process.ppid：当前进程对应的父进程</li><li>process.cwd()：获取当前进程工作目录，</li><li>process.platform：获取当前进程运行的操作系统平台</li><li>process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值</li><li>进程事件：process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听</li><li>三个标准流：process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出</li><li>process.title 指定进程名称，有的时候需要给进程指定一个名称</li></ul></details><div class="tip custom-block"><p class="custom-block-title"><code>process</code>常见方法</p><ul><li><p><code>process.argv()</code>：在终端通过 node 命令执行时，获取命令行参数，返回值是一个数组</p><pre><code>- [0] node路径 （一般用不到）
- [1] 当前执行的文件路径 （一般用不到）
- 2-n : 参数 （一般都这样 process.argv.slice(2) 拿命令行输入的参数）
</code></pre></li><li><p><code>process.cwd()</code>：返回当前 Node 进程执行的目录</p></li></ul></div><h3 id="_2-cp-r-source-target-拷贝目录命令" tabindex="-1">2. <code>cp -r source/* target</code> 拷贝目录命令 <a class="header-anchor" href="#_2-cp-r-source-target-拷贝目录命令" aria-label="Permalink to &quot;2. \`cp -r source/* target\` 拷贝目录命令&quot;">​</a></h3><ul><li>终端下通过 <code>cp -r source/* target</code> 可以快速实现目录的拷贝 <code>source</code>：源目录，target：目标目录</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  cp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">r demo demo1 </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将 demo 目录 拷贝一份到 demo1 ，没有就新建</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  cp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">r demo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">file demo2 </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将 demo 目录下的 file 拷贝到 demo2</span></span></code></pre></div><h2 id="_1-基本信息" tabindex="-1">1. 基本信息 <a class="header-anchor" href="#_1-基本信息" aria-label="Permalink to &quot;1. 基本信息&quot;">​</a></h2><ul><li><p><strong><code>NodeJS</code>是一个 JS 脚本解析器</strong>，任何操作系统下安装<code>NodeJS</code>本质上做的事情都是<strong>把 NodeJS 执行程序复制到一个目录</strong>，然后<strong>保证这个目录在系统 <code>PATH</code> 环境变量下</strong>，以便终端下可以使用 node 命令。</p></li><li><p>终端下直接输入 node 命令可进入命令交互模式，很适合用来测试一些 JS 代码片段，比如正则表达式。</p></li><li><p>NodeJS 使用 CMD 模块系统，主模块作为程序入口点，<strong>所有模块在执行过程中只初始化一次</strong>。</p></li><li><p>除非 JS 模块不能满足需求，否则不要轻易使用二进制模块，否则你的用户会叫苦连天。</p></li></ul><h2 id="_2-模块路径解析规则" tabindex="-1">2. 模块路径解析规则 <a class="header-anchor" href="#_2-模块路径解析规则" aria-label="Permalink to &quot;2. 模块路径解析规则&quot;">​</a></h2><ul><li><strong>内置模块</strong>：不做路径解析，<strong>直接返回内部模块的导出对象</strong>，例如<code>require(fs)</code></li><li><code>node-modules</code>目录：在模块<code>/home/user/hello.js</code>中使用<code>require(&#39;foo/bar&#39;)</code>，那么会依次查找<div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">home</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">modules</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bar</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">modules</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bar</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">modules</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bar</span></span></code></pre></div></li><li><code>NODE_PATH</code>变量：<code>NodeJs</code>允许通过<code>NODE_PATH</code>环境变量来设置搜索路径，可以设置一个或者多个目录，在<code>linux</code>下使用<code>:</code>，在<code>window</code>下使用<code>;</code>分隔，例如：</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 环境变量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NODE_PATH</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;/home/user/lib:/home/lib&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requir</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo / bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 查找路径</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/home/user/lib/foo/bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/home/lib/foo/bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="_3-包package" tabindex="-1">3. 包<code>package</code> <a class="header-anchor" href="#_3-包package" aria-label="Permalink to &quot;3. 包\`package\`&quot;">​</a></h2><ul><li>js 模块的基本单位是 js 文件，多个子模块组成大模块，称为包，并把子模块放在同一目录中</li><li>当模块的文件名为<code>index.js</code>时，<strong>加载模块时可以使用模块所在目录的路径代替模块文件路径</strong>，下面两条语句等价</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/home/user/lib/cat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/home/user/lib/cat/index&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><ul><li><code>package.json</code>文件，自定义入口模块的<strong>文件名</strong>和<strong>入口位置</strong>，可以使用<code>require(&quot;/home/user/lib/cat&quot;)</code>来加载模块</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package.json</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 包名，在npm上必须唯一</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./lib/main.js&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 入口位置</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_4-fs模块" tabindex="-1">4. <code>fs</code>模块 <a class="header-anchor" href="#_4-fs模块" aria-label="Permalink to &quot;4. \`fs\`模块&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title"><code>fs</code>模块</p><ul><li><p>引入 <code> const fs = require(&#39;fs&#39;)</code></p></li><li><p><code>fs.readFileSync(文件路径,options)</code> ：从源路径读取文件内容</p></li><li><p><code>fs.writeFileSync(目标文件路径（无新建）</code>,写入文件,options)：写入文件</p></li><li><p><code>fs.readdirSync(dir)</code> 读取目录内容</p></li><li><p><code>fs.existsSync(path)</code> 如果路径存在则返回 true，否则返回 false</p></li><li><p><code>fs.createReadStream()</code>：创建一个源文件的只读的数据流</p></li><li><p><code>fs.createWriteStream()</code>：创建一个目标文件的只写数据流</p></li><li><p><code>.pipe</code>进行连接：<code>js fs.createReadStream(src).pipe(fs.createWriteStream(dst));</code></p></li><li><p><strong>文件属性读写</strong>。</p></li></ul><p>其中常用的有<code>fs.stat</code>、<code>fs.chmod</code>、<code>fs.chown</code>等等。</p><ul><li><strong>文件内容读写</strong>。</li></ul><p>其中常用的有<code>fs.readFile</code>、<code>fs.readdir</code>、<code>fs.writeFile</code>、<code>fs.mkdir</code>等等。</p><ul><li><strong>底层文件操作</strong>。</li></ul><p>其中常用的有<code>fs.open</code>、<code>fs.read</code>、<code>fs.write</code>、<code>fs.close</code>等等。</p></div><details class="details custom-block"><summary><code>fs.stats(), fs.statsync() </code>: 获取文件信息状态</summary><ol><li>异步方法 <code>fs.stat()</code> fs.stat(path,callback)，path 表示文件路径； callback 是指回调函数，有两个参数：(err,stats)，其中 stats 是 fs.stat 的实例；</li><li>同步方法 <code>fs.statsync()</code> fs.statsync(path),只接收一个 path 变量，fs.statSync(path)其实是一个 fs.stats 的一个实例</li></ol><p><strong>常用的方法：</strong></p><ol><li><p><code>stats.isFile()</code>: 如果是文件则返回 true,否则返回 false;</p></li><li><p><code>stats.isDirectiory()</code>: 如果是目录则返回 true,否则返回 false;</p></li><li><p><code>stats.isBlockDevice()</code>: 如果是块设备则返回 true，否则返回 false;</p></li><li><p><code>stats.isCharacterDevice()</code>: 如果是字符设备返回 true,否则返回 false;</p></li><li><p><code>stats.isSymbolicLink()</code>: 如果是软链接返回 true,否则返回 false;</p></li><li><p><code>stats.isFIFO()</code>: 如果是 FIFO,则返回 true,否则返回 false.FIFO 是 UNIX 中的一种特殊类型的命令管道；</p></li><li><p><code>stats.isSocket()</code>: 如果是 Socket 则返回 true,否则返回 false;</p></li><li><p><code>stats.size()</code>: 文件的大小（以字节为单位）。</p></li></ol></details><h2 id="_5-path模块" tabindex="-1">5. <code>path</code>模块 <a class="header-anchor" href="#_5-path模块" aria-label="Permalink to &quot;5. \`path\`模块&quot;">​</a></h2>`,33)),i("div",r,[s[3]||(s[3]=i("p",{class:"custom-block-title"},"path",-1)),i("ul",null,[i("li",null,[s[0]||(s[0]=i("p",null,[i("code",null,"path.normalize()"),a(": 将传入的路径转换为"),i("strong",null,"标准路径"),a("，"),i("strong",null,"解析"),a("路径中的"),i("code",null,"."),a("与"),i("code",null,".."),a("，还能"),i("strong",null,"去掉"),a("多余的斜杠。")],-1)),k(t,{text:"注意："}),s[1]||(s[1]=n('标准化之后的路径里的斜杠在 <strong>Windows 系统下是<code>\\</code></strong> ，而在<strong>Linux 系统下是<code>/</code></strong>。如果想保证任何系统下都使用<code>/</code>作为路径分隔符的话，需要用 <strong><code>.replace(/\\\\/g, &#39;/&#39;)</code></strong> 再替换一下标准路径。<div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo//baz//../bar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;foo/bar&quot;</span></span></code></pre></div>',10))]),s[2]||(s[2]=n(`<li><p><code>path.join()</code>：将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;baz/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;../bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; &quot;foo/bar&quot;</span></span></code></pre></div></li><li><p><code>path.extname()</code>：<strong>返回 <code>path</code> 的扩展名</strong>，即 <code>path</code> 的最后一部分中从最后一次出现的 .（句点）字符到字符串的结尾</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">extname</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo/bar.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; &quot;.js&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">extname</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index.html&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; &#39;.html&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">extname</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; &#39;.&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">extname</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; &#39;&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">extname</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;.index&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; &#39;&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">extname</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;.index.md&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; &#39;.md&#39;</span></span></code></pre></div></li><li><p><code>path.resolve()</code>： 路径或路径片段的序列解析为<strong>绝对路径</strong>。<strong>给定的路径序列从右到左处理，每个后续的 path 会被追加到前面，直到构建绝对路径。</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 因为 baz 不是绝对路径，但是 /bar/baz 是</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;baz&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; &#39;/bar/baz&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/foo/bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./baz&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; &#39;/foo/bar/baz&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/foo/bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/tmp/file/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; &#39;/tmp/file&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;wwwroot&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;static_files/png/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;../gif/image.gif&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果当前工作目录是 /home/myself/node，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 则返回 &#39;/home/myself/node/wwwroot/static_files/gif/image.gif&#39;</span></span></code></pre></div></li><li><p><code>path.sep</code>：返回当前系统文件路径使用的分隔符，如在 Windows 操作系统上，path.sep 的值为反斜杠 \\，而在 Unix 操作系统上则为正斜杠 /。</p></li>`,4))])]),s[5]||(s[5]=n(`<h2 id="_6-单字节编码" tabindex="-1">6 .单字节编码 <a class="header-anchor" href="#_6-单字节编码" aria-label="Permalink to &quot;6 .单字节编码&quot;">​</a></h2><details class="details custom-block"><summary>Details</summary><ol><li><code>ASCII编码</code>：单字节编码。最初的编码，由一个字节组成，因此只能表示 256 个字符，但只表示 0-9，a-z，A-Z，和一些加减乘除百分号，够老美用了</li><li><code>ANSI编码</code>：多字节编码。</li></ol><ul><li><p>由于一个字节只能表示 255 个数字，所以<strong>中国</strong>约定了<strong>GBK 编码规则</strong>，约定用 <code>0x80-0xFF</code> 范围内的某两个字节来表示某一个中文字符。</p></li><li><p>日本约定了 JIS 编码规则，他们约定 0x80-0xFF 范围内的某两个字节来表示某个日文字符。</p></li><li><p>台湾约定了 BIG5 编码规则，约定 0x80-0xFF 范围内的某两个字节表示某个繁体中文字符。</p></li><li><p>所以我们拿到了一个 ANSI 字节串的时候，我们还必须知道这个字节串的编码，才能将这个字节串转换成相应国家的字符串。</p></li></ul><ol start="3"><li><code>UNICODE编码</code>：宽字节编码。</li></ol></details><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li>字节： <strong>字节（Byte）是一种计量单位，表示数据量多少</strong>，它是计算机信息技术用于计量存储容量的一种<strong>计量单位</strong>。</li><li>字符：字符是指计算机中使用的文字和符号，比如 1、2、3、A、B、C、~！·#￥%……—*（）——+、等等。</li></ol><ul><li><p>①ASCII 码中，一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为 8 位二进制数，换算为十进制。<strong>最小值 0，最大值 255</strong>。</p></li><li><p>②UTF-8 编码中，一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。</p></li><li><p>③Unicode 编码中，一个英文等于两个字节，一个中文（含繁体）等于两个字节。符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占 1 个字节的大小，中文句号“。”占 2 个字节的大小。</p></li><li><p>④UTF-16 编码中，一个英文字母字符或一个汉字字符存储都需要 2 个字节（Unicode 扩展区的一些汉字存储需要 4 个字节）。</p></li><li><p>⑤UTF-32 编码中，世界上任何字符的存储都需要 4 个字节。</p></li></ul></div><h2 id="_7-http模块" tabindex="-1">7. <code>http</code>模块 <a class="header-anchor" href="#_7-http模块" aria-label="Permalink to &quot;7. \`http\`模块&quot;">​</a></h2><p><strong>&#39;http&#39;模块提供两种使用方式：</strong></p><ul><li><p>作为服务端使用时，创建一个 HTTP 服务器，监听 HTTP 客户端请求并返回响应。</p></li><li><p>作为客户端使用时，发起一个 HTTP 客户端请求，获取服务端响应。</p></li></ul><div class="warning custom-block"><p class="custom-block-title">注意点：</p><p>问： 为什么 http 模块创建的 HTTP 服务器返回的响应是 chunked 传输方式的？</p><p>答： 因为默认情况下，使用.writeHead 方法写入响应头后，允许使用.write 方法写入任意长度的响应体数据，并使用.end 方法结束一个响应。由于响应体数据长度不确定，因此 NodeJS 自动在响应头里添加了 Transfer-Encoding: chunked 字段，并采用 chunked 传输方式。但是当响应体数据长度确定时，可使用.writeHead 方法在响应头里加上 Content-Length 字段，这样做之后 NodeJS 就不会自动添加 Transfer-Encoding 字段和使用 chunked 传输方式。</p><p>问： 为什么使用 http 模块发起 HTTP 客户端请求时，有时候会发生 socket hang up 错误？</p><p>答： 发起客户端 HTTP 请求前需要先创建一个客户端。http 模块提供了一个全局客户端 http.globalAgent，可以让我们使用.request 或.get 方法时不用手动创建客户端。但是全局客户端默认只允许 5 个并发 Socket 连接，当某一个时刻 HTTP 客户端请求创建过多，超过这个数字时，就会发生 socket hang up 错误。解决方法也很简单，通过 http.globalAgent.maxSockets 属性把这个数字改大些即可。另外，https 模块遇到这个问题时也一样通过 https.globalAgent.maxSockets 属性来处理</p></div><h2 id="_8-进程管理" tabindex="-1">8. 进程管理 <a class="header-anchor" href="#_8-进程管理" aria-label="Permalink to &quot;8. 进程管理&quot;">​</a></h2><ul><li><ol><li><code>process</code>:process 不是内置模块，而是一个全局对象，</li></ol><ul><li>官方文档： <a href="http://nodejs.org/api/process.html" target="_blank" rel="noreferrer">http://nodejs.org/api/process.html</a></li></ul></li><li><ol start="2"><li><code>child_process</code>:模块可以创建和控制子进程,该模块提供的 API 中最核心的是.spawn，其余 API 都是针对特定使用场景对它的进一步封装，算是一种语法糖。</li></ol><ul><li>官方文档： <a href="http://nodejs.org/api/child_process.html" target="_blank" rel="noreferrer">http://nodejs.org/api/child_process.html</a></li></ul></li><li><ol start="3"><li><code>Cluster</code>:cluster 模块是对 child_process 模块的进一步封装，<strong>专用于解决单进程 NodeJS Web 服务器无法充分利用多核 CPU 的问题</strong>。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。</li></ol><ul><li>官方文档： <a href="http://nodejs.org/api/cluster.html" target="_blank" rel="noreferrer">http://nodejs.org/api/cluster.html</a></li></ul></li></ul><h3 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><h4 id="_1-如何获取命令行参数" tabindex="-1">1. 如何获取命令行参数 <a class="header-anchor" href="#_1-如何获取命令行参数" aria-label="Permalink to &quot;1. 如何获取命令行参数&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">argvs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(process.argv.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><h4 id="_2-如何退出程序" tabindex="-1">2. 如何退出程序 <a class="header-anchor" href="#_2-如何退出程序" aria-label="Permalink to &quot;2. 如何退出程序&quot;">​</a></h4><p>通常一个程序做完所有事情后就<strong>正常退出了，这时程序的退出状态码为 0</strong>。或者一个程序运行时<strong>发生异常后挂了，这时程序的退出状态码不等于 0</strong>。如果我们在代码中捕获了某个异常，但是觉得程序不应该继续运行下去，需要立即退出，并且需要把退出状态码设置为指定数字，比如 1，就可以按照以下方式：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (err) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_3-如何控制输入输出" tabindex="-1">3. 如何控制输入输出 <a class="header-anchor" href="#_3-如何控制输入输出" aria-label="Permalink to &quot;3. 如何控制输入输出&quot;">​</a></h4><p>NodeJS 程序的<strong>标准输入流<code>（stdin）</code></strong>、一个<strong>标准输出流<code>（stdout）</code></strong>、一个 <strong>标准错误流<code>(stderr)</code></strong>、分别对应 <strong>process.stdin</strong>、<strong>process.stdout</strong> 和 <strong>process.stderr</strong>，第一个是只读数据流，后边两个是只写数据流，对它们的操作按照对数据流的操作方式即可。例如，console.log 可以按照以下方式实现。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  process.stdout.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          util.format.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(util, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">arguments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><h4 id="_4-如何降权" tabindex="-1">4. 如何降权 <a class="header-anchor" href="#_4-如何降权" aria-label="Permalink to &quot;4. 如何降权&quot;">​</a></h4><p>在 Linux 系统下，我们知道需要<strong>使用 root 权限才能监听 1024 以下端口</strong>。但是一旦<strong>完成端口监听后，继续让程序运行在 root 权限下存在安全隐患</strong>，因此最好能把权限降下来。以下是这样一个例子。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">http.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果是通过sudo获取root权限的，运行程序的用户的UID和GID保存在环境变量SUDO_UID和SUDO_GID里边。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果是通过chmod +s方式获取root权限的，运行程序的用户的UID和GID可直接通过process.getuid和process.getgid方法获取。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> env </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> process.env,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    uid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parseInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(env[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;SUDO_UID&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getuid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    gid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parseInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(env[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;SUDO_GID&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getgid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 降权时必须先降GID再降UID，否则顺序反过来的话就没权限更改程序的GID了。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setgid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gid); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 先降GID  process.setgid(gid) 只接受number类型参数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setuid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uid); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 再降UID   process.setuid(uid) 只接受number类型参数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h4 id="_5-如何创建子进程" tabindex="-1">5. 如何创建子进程 <a class="header-anchor" href="#_5-如何创建子进程" aria-label="Permalink to &quot;5. 如何创建子进程&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// spawn(exec, args, options)方法支持三个参数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// exec：参数是执行文件路径，可以是执行文件的相对或绝对路径，也可以是根据PATH环境变量能找到的执行文件名。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// args：数组中的每个成员都按顺序对应一个命令行参数。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// options：用于配置子进程的执行环境与行为。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> child</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child_process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;xxx.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">child.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stdout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;stdout: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">child.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stderr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;stderr: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">child.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;close&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;child process exited with code &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> code);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h4 id="_6-进程间如何通讯" tabindex="-1">6. 进程间如何通讯 <a class="header-anchor" href="#_6-进程间如何通讯" aria-label="Permalink to &quot;6. 进程间如何通讯&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* parent.js */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> child</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child_process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;child.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 父进程通过 .kill 方法向子进程发送 SIGTERM 信号</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">child.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;SIGTERM&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* child.js */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;SIGTERM&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 子进程通过监听 process 对象的的SIGTERM事件响应信号</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  cleanUp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p><strong>父子进程都是 NodeJS 进程，就可以通过 IPC（进程间通讯）双向传递数据</strong> 据在传递过程中，会先在发送端使用 <code>JSON.stringify</code> 方法序列化，再在接收端使用 <code>JSON.parse</code> 方法反序列化。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* parent.js */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child_process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;child.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  stdio: [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ipc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//父进程在创建子进程时，在options.stdio字段中通过ipc开启了一条IPC通道</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 监听子进程对象的 message 事件接收 来自子进程的消息，</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">child.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">msg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(msg);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 并通过.send方法给子进程发送消息。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">child.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ hello: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* child.js */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">msg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 监听 process 对象的 message 事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  msg.hello </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> msg.hello.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toUpperCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 通过 .send 方法向父进程传递信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(msg);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h4 id="_7-如何守护子进程" tabindex="-1">7. 如何守护子进程 <a class="header-anchor" href="#_7-如何守护子进程" aria-label="Permalink to &quot;7. 如何守护子进程&quot;">​</a></h4><p><strong>守护进程一般用于监控工作进程的运行状态，在工作进程不正常退出时重启工作进程</strong>，保障工作进程不间断运行。以下是一种实现方式。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* daemon.js */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mainModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> worker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child_process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [mainModule]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  worker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;exit&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 工作进程非正常退出时，守护进程立即重启工作进程。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (code </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mainModule);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;worker.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="_9-异步编程" tabindex="-1">9. 异步编程 <a class="header-anchor" href="#_9-异步编程" aria-label="Permalink to &quot;9. 异步编程&quot;">​</a></h2><h3 id="域-domain" tabindex="-1">域（domain） <a class="header-anchor" href="#域-domain" aria-label="Permalink to &quot;域（domain）&quot;">​</a></h3><ol><li>一个域就是一个 js 运行环境，在一个运行环境中，如果一个异常没有被捕获，就会作为一个全局异常被抛出，nodejs 中通过 process 对象提供捕获全局异常的方法</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;uncaughtException&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Error: %s&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, err.message);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Error: undefined is not a function</span></span></code></pre></div><ol start="2"><li>通过 域（domain）对象监听 error 事件，捕获异常</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> domain.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;error&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeHead</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">500</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="注意点-⚠️" tabindex="-1">注意点 ⚠️ <a class="header-anchor" href="#注意点-⚠️" aria-label="Permalink to &quot;注意点 ⚠️&quot;">​</a></h3><ul><li>官方建议无论是通过<code>process</code>还是<code>domian</code>处理异常后都要重启程序，因为处理异常后的程序处于一种<strong>不确定的运行状态</strong>，可能导致<strong>内存泄漏</strong>或者<strong>表现的很奇怪</strong></li><li>JS 本身的 throw..try..catch 异常处理机制并不会导致内存泄漏，也不会让程序的执行结果出乎意料，但 NodeJS 并不是存粹的 JS。NodeJS 里大量的 API 内部是用 C/C++实现的，因此 NodeJS 程序的运行过程中，代码执行路径穿梭于 JS 引擎内部和外部，而 JS 的异常抛出机制可能会打断正常的代码执行流程，导致 C/C++部分的代码表现异常，进而导致内存泄漏等问题</li></ul>`,38))])}const C=l(d,[["render",o]]);export{b as __pageData,C as default};
