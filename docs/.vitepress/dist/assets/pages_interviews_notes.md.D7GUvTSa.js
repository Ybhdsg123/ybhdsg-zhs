import{_ as a,c as l,o as i,ag as o}from"./chunks/framework.By2cXeI6.js";const s=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pages/interviews/notes.md","filePath":"pages/interviews/notes.md"}'),r={name:"pages/interviews/notes.md"};function t(u,e,h,p,n,d){return i(),l("div",null,[...e[0]||(e[0]=[o('<h2 id="面试题-自己想到的" tabindex="-1">面试题 --- 自己想到的 <a class="header-anchor" href="#面试题-自己想到的" aria-label="Permalink to &quot;面试题 --- 自己想到的&quot;">​</a></h2><h3 id="vue2-3的区别和升级-vue3还有哪些好处" tabindex="-1">vue2/3的区别和升级，vue3还有哪些好处 <a class="header-anchor" href="#vue2-3的区别和升级-vue3还有哪些好处" aria-label="Permalink to &quot;vue2/3的区别和升级，vue3还有哪些好处&quot;">​</a></h3><h4 id="区别与升级" tabindex="-1">区别与升级： <a class="header-anchor" href="#区别与升级" aria-label="Permalink to &quot;区别与升级：&quot;">​</a></h4><ol><li><p>核心架构：Vue 3 使用基于 Proxy 的响应式替代 Vue 2 的 Object.defineProperty。</p></li><li><p>性能提升：Vue 3 体积更小，初始化、渲染和更新速度更快。</p></li><li><p>Composition API：Vue 3 引入了 Composition API，增强了逻辑复用能力。</p></li><li><p>Tree-shaking：支持按需打包未使用的模块，减小项目体积。</p></li><li><p>Fragments：Vue 3 支持组件返回多个根节点。</p></li><li><p>更好的 TypeScript 支持。</p></li></ol><h4 id="vue-3-好处" tabindex="-1">Vue 3 好处： <a class="header-anchor" href="#vue-3-好处" aria-label="Permalink to &quot;Vue 3 好处：&quot;">​</a></h4><ol><li><p>更强的灵活性，支持大型项目的开发。</p></li><li><p>通过 Composition API 提高了代码的可读性和组织能力。</p></li></ol><h3 id="webpack和vite的区别-vite的好处" tabindex="-1">webpack和vite的区别，vite的好处 <a class="header-anchor" href="#webpack和vite的区别-vite的好处" aria-label="Permalink to &quot;webpack和vite的区别，vite的好处&quot;">​</a></h3><h4 id="区别" tabindex="-1">区别： <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别：&quot;">​</a></h4><ol><li>开发模式：</li></ol><ul><li><p>Webpack 使用构建时间作为开发环境的基础。</p></li><li><p>Vite 使用浏览器的原生 ESM 功能，实现即时启动，无需预构建。</p></li></ul><ol start="2"><li>热更新 (HMR)：</li></ol><ul><li><p>Webpack 热更新基于模块系统。</p></li><li><p>Vite 利用 ESM 的动态导入机制，热更新更快。</p></li></ul><ol start="3"><li>打包效率：</li></ol><ul><li><p>Webpack 对大项目打包速度较慢。</p></li><li><p>Vite 使用 Rollup 进行构建，速度更快。</p></li></ul><h4 id="vite-好处" tabindex="-1">Vite 好处： <a class="header-anchor" href="#vite-好处" aria-label="Permalink to &quot;Vite 好处：&quot;">​</a></h4><ul><li><p>快速启动，特别适用于大型项目。</p></li><li><p>高效热更新，开发体验更好。</p></li><li><p>更好的支持现代化 JavaScript（例如 ESM 模块）。</p></li></ul><h3 id="webpack的loader和plugin的区别" tabindex="-1">webpack的loader和plugin的区别 <a class="header-anchor" href="#webpack的loader和plugin的区别" aria-label="Permalink to &quot;webpack的loader和plugin的区别&quot;">​</a></h3><h4 id="loader-用于转换文件-例如-css、图片、es6-转-es5-等。它是模块处理器。" tabindex="-1">Loader：用于转换文件，例如 CSS、图片、ES6 转 ES5 等。它是模块处理器。 <a class="header-anchor" href="#loader-用于转换文件-例如-css、图片、es6-转-es5-等。它是模块处理器。" aria-label="Permalink to &quot;Loader：用于转换文件，例如 CSS、图片、ES6 转 ES5 等。它是模块处理器。&quot;">​</a></h4><ul><li>示例：css-loader, babel-loader。</li></ul><h4 id="plugin-用于扩展-webpack-功能-比如压缩文件、优化资源等。它是功能增强器。" tabindex="-1">Plugin：用于扩展 Webpack 功能，比如压缩文件、优化资源等。它是功能增强器。 <a class="header-anchor" href="#plugin-用于扩展-webpack-功能-比如压缩文件、优化资源等。它是功能增强器。" aria-label="Permalink to &quot;Plugin：用于扩展 Webpack 功能，比如压缩文件、优化资源等。它是功能增强器。&quot;">​</a></h4><ul><li>示例：HtmlWebpackPlugin, DefinePlugin。</li></ul><h3 id="webpack-进行热更新的原理" tabindex="-1">webpack 进行热更新的原理 <a class="header-anchor" href="#webpack-进行热更新的原理" aria-label="Permalink to &quot;webpack 进行热更新的原理&quot;">​</a></h3><h4 id="webpack-的热更新-hot-module-replacement-hmr-通过以下方式实现" tabindex="-1">Webpack 的热更新（Hot Module Replacement, HMR）通过以下方式实现： <a class="header-anchor" href="#webpack-的热更新-hot-module-replacement-hmr-通过以下方式实现" aria-label="Permalink to &quot;Webpack 的热更新（Hot Module Replacement, HMR）通过以下方式实现：&quot;">​</a></h4><ol><li><p>Webpack Dev Server 启动一个 WebSocket 服务器。</p></li><li><p>代码文件修改后，Webpack 编译模块并通过 WebSocket 通知浏览器。</p></li><li><p>浏览器接收到更新信息后，仅替换修改的模块，而非刷新整个页面。</p></li></ol><h3 id="vue3的响应式原理" tabindex="-1">vue3的响应式原理 <a class="header-anchor" href="#vue3的响应式原理" aria-label="Permalink to &quot;vue3的响应式原理&quot;">​</a></h3><h4 id="vue-3-使用-es6-的-proxy-实现响应式" tabindex="-1">Vue 3 使用 ES6 的 Proxy 实现响应式： <a class="header-anchor" href="#vue-3-使用-es6-的-proxy-实现响应式" aria-label="Permalink to &quot;Vue 3 使用 ES6 的 Proxy 实现响应式：&quot;">​</a></h4><ul><li><p>拦截对对象的读取（get）和写入（set）。</p></li><li><p>动态追踪依赖，结合 effect 收集使用到的响应式数据。</p></li><li><p>修改数据时，自动触发依赖的重新渲染。</p></li></ul><h3 id="vue3的diff算法" tabindex="-1">vue3的diff算法 <a class="header-anchor" href="#vue3的diff算法" aria-label="Permalink to &quot;vue3的diff算法&quot;">​</a></h3><h4 id="vue-3-使用-双端对比算法-提升了性能" tabindex="-1">Vue 3 使用 双端对比算法，提升了性能： <a class="header-anchor" href="#vue-3-使用-双端对比算法-提升了性能" aria-label="Permalink to &quot;Vue 3 使用 双端对比算法，提升了性能：&quot;">​</a></h4><ul><li><p>从两边同时开始比较（头对头，尾对尾）。</p></li><li><p>优化了节点移动和复用，减少了 DOM 操作次数。</p></li></ul><h3 id="vue3的虚拟dom和真实dom" tabindex="-1">vue3的虚拟dom和真实dom <a class="header-anchor" href="#vue3的虚拟dom和真实dom" aria-label="Permalink to &quot;vue3的虚拟dom和真实dom&quot;">​</a></h3><h4 id="虚拟-dom" tabindex="-1">虚拟 DOM： <a class="header-anchor" href="#虚拟-dom" aria-label="Permalink to &quot;虚拟 DOM：&quot;">​</a></h4><ul><li><p>是一层 JavaScript 描述对象。</p></li><li><p>在内存中模拟真实 DOM 结构，用于高效渲染。</p></li></ul><h4 id="真实-dom" tabindex="-1">真实 DOM： <a class="header-anchor" href="#真实-dom" aria-label="Permalink to &quot;真实 DOM：&quot;">​</a></h4><ul><li><p>是浏览器的文档对象，用于显示 UI。</p></li><li><p>修改真实 DOM 操作开销较高，虚拟 DOM 可优化其性能。</p></li></ul><h3 id="vue3的组件化原理" tabindex="-1">vue3的组件化原理 <a class="header-anchor" href="#vue3的组件化原理" aria-label="Permalink to &quot;vue3的组件化原理&quot;">​</a></h3><ul><li><p>每个组件是一个独立的 Vue 实例。</p></li><li><p>Vue 通过 render 函数将组件的模板编译成虚拟 DOM 树，并映射到真实 DOM。</p></li><li><p>父子组件通过属性（props）和事件（emit）进行数据流传递。</p></li></ul><h3 id="vue3的组件通信" tabindex="-1">vue3的组件通信 <a class="header-anchor" href="#vue3的组件通信" aria-label="Permalink to &quot;vue3的组件通信&quot;">​</a></h3><h3 id="vue3的组件生命周期" tabindex="-1">vue3的组件生命周期 <a class="header-anchor" href="#vue3的组件生命周期" aria-label="Permalink to &quot;vue3的组件生命周期&quot;">​</a></h3><h3 id="vue3的组件懒加载" tabindex="-1">vue3的组件懒加载 <a class="header-anchor" href="#vue3的组件懒加载" aria-label="Permalink to &quot;vue3的组件懒加载&quot;">​</a></h3><h3 id="vue3的组件懒加载原理" tabindex="-1">vue3的组件懒加载原理 <a class="header-anchor" href="#vue3的组件懒加载原理" aria-label="Permalink to &quot;vue3的组件懒加载原理&quot;">​</a></h3><h3 id="vue3的组件懒加载的实现原理" tabindex="-1">vue3的组件懒加载的实现原理 <a class="header-anchor" href="#vue3的组件懒加载的实现原理" aria-label="Permalink to &quot;vue3的组件懒加载的实现原理&quot;">​</a></h3>',42)])])}const b=a(r,[["render",t]]);export{s as __pageData,b as default};
