import{_ as i,c as a,o as e,ag as t}from"./chunks/framework.By2cXeI6.js";const k=JSON.parse('{"title":"vite 相关","description":"","frontmatter":{},"headers":[],"relativePath":"pages/vite/index.md","filePath":"pages/vite/index.md"}'),l={name:"pages/vite/index.md"};function n(o,s,d,p,r,h){return e(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="vite-相关" tabindex="-1">vite 相关 <a class="header-anchor" href="#vite-相关" aria-label="Permalink to &quot;vite 相关&quot;">​</a></h1><h2 id="_1-import-meta-glob-获取文件夹下的文件" tabindex="-1">1. <a href="https://cn.vitejs.dev/guide/features.html#glob-import" target="_blank" rel="noreferrer"><code>import.meta.glob</code></a> 获取文件夹下的文件 <a class="header-anchor" href="#_1-import-meta-glob-获取文件夹下的文件" aria-label="Permalink to &quot;1. [\`import.meta.glob\`](https://cn.vitejs.dev/guide/features.html#glob-import) 获取文件夹下的文件&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取所有组件信息</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> allRoutes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;@/components/**/index.vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //设置为 true 直接引入所有的模块（例如依赖于这些模块中的副作用首先被应用）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  eager: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 加载默认导出，不加这个需要这样获取文件  allRoutes[key].default.name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  import: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;default&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> allRoutes) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allRoutes[key].name, allRoutes[key]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="_2-vite-比-webpack-快的原因" tabindex="-1">2. vite 比 webpack 快的原因 <a class="header-anchor" href="#_2-vite-比-webpack-快的原因" aria-label="Permalink to &quot;2. vite 比 webpack 快的原因&quot;">​</a></h2><p><a href="https://cn.vitejs.dev/guide/why.html#footnote-1" target="_blank" rel="noreferrer">vite 官网地址</a></p><details class="details custom-block"><summary><code>webpack</code>：分析依赖 ==&gt; 编译打包 ==&gt; 交给本地服务器渲染</summary><ul><li>分析各个模块之间的依赖，再进行打包，然后通过<code>webpack-dev-server</code>请求，显示结果。</li><li>项目体积变大，<code>bundle</code>体积增加，影响热更新速度</li></ul></details><details class="details custom-block"><summary><code>vite</code>: 开发阶段通过 <code>esbuild</code>构建，生产环境通过 <code>rollup</code> 进行构建</summary><ul><li><code>Vite</code>在一开始时就将应用中的模块分为<strong>依赖</strong>和<strong>源码</strong>，</li><li><strong>依赖</strong>：大多为在开发时不会变动的纯 JavaScript， <ul><li><strong><code>Vite</code>采用 <code>esbuild</code> 进行依赖预购建，依赖不改变，不需要重新构建，</strong></li></ul></li><li><strong>源码</strong>：通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue/Svelte 组件），时常会被编辑。 <ul><li><code>Vite</code>以原生<code>ES Modules(ESM)</code>形式提供源码，因为浏览器可以直接解析<code>ES Modules(ESM)</code>，<code>&lt;script type=&#39;module&#39;&gt;&lt;/script&gt;</code>来使用浏览器的 <code>ESM</code> 模块加载模块。</li><li>这实际是让浏览器接手打包程序的的部分工作：<strong><code>Vite</code>只需在浏览器请求源码时进行转换并按需提供源码，根据场景动态导入代码(按需导入)</strong></li></ul></li></ul></details><details class="details custom-block"><summary><code>vite</code> 服务热更新更快的原因</summary><ul><li><ol><li>在 Vite 中， <code>HMR</code> 是在原生 <code>ESM</code> 上执行的。当编辑一个文件时，<code>Vite</code> 只需要精确地使已编辑的模块与其最近的 <code>HMR</code> 边界之间的链失活[1]（大多数时候只是模块本身），使得无论应用大小如何，<code>HMR</code> 始终能保持快速更新。</li></ol></li><li><ol start="2"><li><code>Vite</code> 同时利用 <code>HTTP</code> 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）</li></ol></li><li><ol start="3"><li><strong>源码模块</strong>的请求会根据 <code>304 Not Modified</code> 进行<strong>协商缓存</strong></li></ol></li><li><ol start="4"><li><strong>依赖模块</strong>请求则会通过 <code>Cache-Control: max-age=31536000,immutable</code> 进行<strong>强缓存</strong>，因此一旦被缓存它们将不需要再次请求。</li></ol></li></ul></details><div class="tip custom-block"><p class="custom-block-title">总结</p><ol><li>开发阶段构建项目，<code>vite</code> 将应用分为<strong>依赖</strong>和<strong>源码</strong>，对依赖进行预构建，源码通过<code>ESM</code>形式提供，利用浏览器的能力按需加载源码。</li><li><code>HMR</code>是在原生<code>ESM</code>上执行的，精确控制已编辑模块与最近的<code>HMR</code>边界之间的链失活，保持快速更新</li><li>利用<code>HTTP</code>头的缓存，通过对<strong>源码模块</strong>的<strong>协商缓存</strong>，<strong>依赖模块</strong>的<strong>强缓存</strong></li></ol></div><h2 id="_3-依赖预构建" tabindex="-1">3. 依赖预构建 <a class="header-anchor" href="#_3-依赖预构建" aria-label="Permalink to &quot;3. 依赖预构建&quot;">​</a></h2><p><a href="https://cn.vitejs.dev/guide/dep-pre-bundling.html#the-why" target="_blank" rel="noreferrer">vite 官网地址</a></p><p>当你首次启动 vite 时，Vite 在本地加载你的站点之前预构建了项目依赖。默认情况下，它是自动且透明地完成的。</p><h3 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-label="Permalink to &quot;原因&quot;">​</a></h3><ol><li><strong>CommonJS 和 UMD 兼容性</strong>: 在开发阶段中，<strong><code>Vite</code> 的开发服务器将所有代码视为原生 <code>ES</code> 模块</strong>。因此，Vite 必须先将以 CommonJS 或 UMD 形式提供的依赖项转换为 ES 模块。在转换 CommonJS 依赖项时，Vite 会进行智能导入分析，这样即使模块的导出是动态分配的（例如 React），具名导入（named imports）也能正常工作：</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 符合预期</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React, { useState } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;react&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><ol start="2"><li><strong>性能</strong>：为了提高后续页面的加载性能，<strong><code>Vite</code>将那些具有许多内部模块的 <code>ESM</code> 依赖项转换为单个模块。</strong></li></ol><ul><li>有些包将它们的 <code>ES </code>模块构建为许多单独的文件，彼此导入。例如，lodash-es 有超过 600 个内置模块！下载时会进行 600 个请求。</li><li>通过将 lodash-es 预构建成单个模块，现在我们只需要一个 HTTP 请求！</li></ul><div class="warning custom-block"><p class="custom-block-title">注意</p><p>依赖预构建仅适用于开发模式，并使用 esbuild 将依赖项转换为 ES 模块。在生产构建中，将使用 @rollup/plugin-commonjs。</p></div>`,18)])])}const g=i(l,[["render",n]]);export{k as __pageData,g as default};
